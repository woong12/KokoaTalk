margin = box의 border(경계)의 바깥에 있는 공간
margin: x; = 상하좌우 모두 젹용
margin: x x; = 상하 좌우
margin x x x x; 위 오 아 왼


flexbox 사용 규칙
1. 자식 엘리먼트에는 어떤 것도 적지 말아야 함.
자식 엘리먼트를 움직이게 하려면 부모 엘리먼트를 flex container로 만들어야 한다.
2. align-items : cross axis에서 작용 (세로)
3. justify-content : main axis에서 작용 (가로) (디폴트)
flex-container가 height를 가지고 있지 않으면 align-items를 사용하더라도 위치가 바뀌지 않음.
vh = viewport height (스크린에 따라 다름)

1. positon: static (default)
2. position: fixed
- element가 처음 생성된 자리에 고정.
3. position: relative;
- element가 '처음 생성된 위치'를 기준점으로, top bottom left right으로 위치를 조금씩 수정할 수 있다.
4. position: absolute;
가장 가까운 relative 부모를 기준으로 이동
position:relative; 를 해주면 부모가 된다.
없으면 body.

pseudo selector
좀더 세부적으로 엘리먼트를 선택해 주는 것!
(기존 방법 : 태그, id w/#, class w/.)

선택의 복잡한 과정을 pseudo selector로 가능함
ex>
div:first-child {
background-color: tomato;
}

/* pseudo selector */
div:last-child {
background-color: teal;
}
id나 class를 따로 만드는것보다 이렇게 지정하는게 훨씬 좋은 방법이다.
css에서만 선택을 하면 되니까! html코드를 고칠 필요가 없기 때문이다

n번째 태그 수정하기 nth-child(n) 올ㅋ
span:nth-child(2) {
background-color: teal;
}
span:nth-child(even) { //or odd ( 홀수 )
background-color: teal;
}

even은 짝수! 짝수번째를 모두 바꿀 수있다 오 so cool !


span:nth-child(5n + 1) {
background-color: silver;
}
n을 사용하면 매우 편하다
div의 바로 밑 자식에서 span을 찾아서 그것만 효과를 주는 방법
1)
div span {
text-decoration : underline;
}
이렇게하면 div밑에 있는 모든 span이 효과를 가진다
직접적인 부모가 아니어도 밑에있는 것들을 모두 css가 찾는다.

2) div > span {
text-decoration : underline;
}
이렇게하면 바로 밑!!! 을 찾게 되므로 바로 밑의 자식만 건들일수있게된다.

형제에게 효과를 주는방법

p + span {
color: black;

}
+ 를 사용하면 형제에게 영향을 끼칠 수 있다. cool


※ > 를 사용하면 direct child를 찾고, + 를 사용하면 바로 코드상 밑에 있는 sibling을 찾게된다.